{"version":3,"file":"Maze2D.js","mappings":";;;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB,iBAAiB;AACjB,iBAAiB;AACjB,uBAAuB;AACvB,uBAAuB;AACvB,sBAAsB;AACtB,sBAAsB;AACtB;AACA,YAAY;;;;;;;;;;;ACrBC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ;AACA;AACA,mBAAmB,mBAAO,CAAC,oCAAY;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA,wBAAwB,kBAAkB;AAC1C,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yBAAyB,EAAE,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB,EAAE,wBAAwB;AAC1E;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;ACnHC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd,mBAAmB,mBAAO,CAAC,oCAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;;;;;ACzDD;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,mBAAmB,GAAG,mBAAmB;AACzH;AACA;AACA,iBAAiB,mBAAO,CAAC,gCAAU;AACnC,eAAe,mBAAO,CAAC,4BAAQ;AAC/B,mBAAmB;AACnB,mBAAmB;AACnB,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;;;;;;;;;;;ACrGH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;;;;;;UCvBd;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA,eAAe,mBAAO,CAAC,4BAAQ;AAC/B,iBAAiB,mBAAO,CAAC,gCAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB","sources":["webpack://3dmaze/./ts/Cell.ts","webpack://3dmaze/./ts/Maze.ts","webpack://3dmaze/./ts/Maze2D.ts","webpack://3dmaze/./ts/MazeCell.ts","webpack://3dmaze/./ts/Vector.ts","webpack://3dmaze/webpack/bootstrap","webpack://3dmaze/./ts/Maze2DMain.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cell = void 0;\n//Corey Wunderlich 2022\n//https://www.wundervisionenvisionthefuture.com/\nclass Cell {\n    constructor() {\n        this._front = null;\n        this._right = null;\n        this._back = null;\n        this._left = null;\n    }\n    get Front() { return this._front; }\n    get Right() { return this._right; }\n    get Back() { return this._back; }\n    get Left() { return this._left; }\n    set Front(value) { this._front = value; }\n    set Right(value) { this._right = value; }\n    set Back(value) { this._back = value; }\n    set Left(value) { this._left = value; }\n}\nexports.Cell = Cell;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Maze = void 0;\n//Corey Wunderlich 2022\n//https://www.wundervisionenvisionthefuture.com/\nconst MazeCell_1 = require(\"./MazeCell\");\nclass Maze {\n    constructor(size_x, size_y) {\n        this._size_x = size_x;\n        this._size_y = size_y;\n        this._grid = [];\n        for (let y = 0; y < this._size_y; y++) {\n            let row = [];\n            for (let x = 0; x < this._size_x; x++) {\n                const c = new MazeCell_1.MazeCell(x, y);\n                if (y == 0) {\n                    c.Back = MazeCell_1.MazeWall;\n                }\n                else if (y == this._size_y - 1) {\n                    c.Front = MazeCell_1.MazeWall;\n                }\n                if (x == 0) {\n                    c.Left = MazeCell_1.MazeWall;\n                }\n                else if (x == this._size_x - 1) {\n                    c.Right = MazeCell_1.MazeWall;\n                }\n                row.push(c);\n            }\n            this._grid.push(row);\n        }\n    }\n    get SizeX() { return this._size_x; }\n    get SizeY() { return this._size_y; }\n    *CellsItr() {\n        for (let y = 0; y < this._size_y; y++) {\n            for (let x = 0; x < this._size_x; x++) {\n                yield this._grid[y][x];\n            }\n        }\n        return;\n    }\n    GetCell(v) {\n        return this.GetCellXY(v.X, v.Y);\n    }\n    GetCellXY(x, y) {\n        if (x < 0 || x >= this._size_x || y < 0 || y >= this._size_y) {\n            return MazeCell_1.MazeWall;\n        }\n        return this._grid[y][x];\n    }\n    Finalize() {\n        const iterator = this.CellsItr();\n        let itr_ptr = iterator.next();\n        while (itr_ptr.done == false) {\n            itr_ptr.value.Barricade();\n            itr_ptr = iterator.next();\n        }\n    }\n    static Generate(start_x, start_y, width, height) {\n        const maze = new Maze(width, height);\n        let current_cell = maze.GetCellXY(start_x, start_y);\n        if (current_cell == null) {\n            throw \"Invalid Start Coordinates\";\n        }\n        current_cell.Connected = true;\n        // const end_point = new Vector(99,99);\n        const path_stack = [];\n        //While we are not at the endpoint\n        //while(!current_cell.Position.Equals(end_point)){\n        while (true) {\n            //console.log(`${current_cell.Position.X} ${current_cell.Position.Y}`);\n            //get all possible directions to move\n            let vectors = current_cell.AvailableVectors;\n            //If there is no where to go, back up\n            if (vectors.length == 0) {\n                //If there are no more cells to back up..\n                //then something weird is happening break out\n                if (path_stack.length == 0) {\n                    break;\n                }\n                let stack_pop = path_stack.pop();\n                if (stack_pop == undefined) {\n                    throw \"The Path Stack is corrupt\";\n                }\n                current_cell = stack_pop;\n                continue;\n            }\n            //Choose a random direction from available vectors\n            let index = Math.floor(Math.random() * vectors.length);\n            let next_vector = vectors[index];\n            let reverse_next_vector = next_vector.Reverse();\n            let next_cell_position = current_cell.Position.Add(next_vector);\n            const next_cell = maze.GetCell(next_cell_position);\n            if (next_cell == null) {\n                throw \"Something bad happened\";\n            }\n            //If the cell in the chosen direction is already connected\n            //Wall us off from going that way and try again.\n            if (next_cell.Connected) {\n                current_cell.SetCellVector(next_vector, MazeCell_1.MazeWall);\n                continue;\n            }\n            //Make our connections between cells and move to the next cell\n            current_cell.SetCellVector(next_vector, next_cell);\n            next_cell.SetCellVector(reverse_next_vector, current_cell);\n            path_stack.push(current_cell);\n            current_cell = next_cell;\n            current_cell.Connected = true;\n        }\n        console.log(`${current_cell.Position.X} ${current_cell.Position.Y}`);\n        maze.Finalize();\n        return maze;\n    }\n}\nexports.Maze = Maze;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Maze2D = void 0;\nconst MazeCell_1 = require(\"./MazeCell\");\nclass Maze2D {\n    constructor(canvas, maze) {\n        this._canvas = canvas;\n        this._maze = maze;\n        let ctx = this._canvas.getContext('2d');\n        if (ctx == null) {\n            throw \"Could not get 2D Context\";\n        }\n        this._context = ctx;\n        this._context.fillStyle = 'black';\n        this._context.strokeStyle = 'white';\n        this._context.lineWidth = 2;\n        this._context.fillRect(0, 0, this._canvas.width, this._canvas.height);\n        this._wall_width = this._canvas.width / maze.SizeX;\n        this._wall_height = this._canvas.height / maze.SizeY;\n    }\n    get Image() {\n        return this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);\n    }\n    CreateWalls(ctx, cell) {\n        if (!cell.Connected) {\n            return;\n        }\n        const x = this._wall_width * cell.Position.X;\n        const y = this._wall_height * cell.Position.Y;\n        ctx.beginPath();\n        if (cell.Front == MazeCell_1.MazeWall) {\n            ctx.moveTo(x, y + this._wall_height);\n            ctx.lineTo(x + this._wall_width, y + this._wall_height);\n        }\n        if (cell.Right == MazeCell_1.MazeWall) {\n            ctx.moveTo(x + this._wall_width, y + this._wall_height);\n            ctx.lineTo(x + this._wall_width, y);\n        }\n        if (cell.Back == MazeCell_1.MazeWall) {\n            ctx.moveTo(x + this._wall_width, y);\n            ctx.lineTo(x, y);\n        }\n        if (cell.Left == MazeCell_1.MazeWall) {\n            ctx.moveTo(x, y);\n            ctx.lineTo(x, y + this._wall_height);\n        }\n        ctx.stroke();\n    }\n    CreateMaze() {\n        const iterator = this._maze.CellsItr();\n        let itr_ptr = iterator.next();\n        while (itr_ptr.done == false) {\n            this.CreateWalls(this._context, itr_ptr.value);\n            itr_ptr = iterator.next();\n        }\n    }\n}\nexports.Maze2D = Maze2D;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MazeWall = exports.MazeCell = exports.LeftVector = exports.BackVector = exports.RightVector = exports.FrontVector = void 0;\n//Corey Wunderlich 2022\n//https://www.wundervisionenvisionthefuture.com/\nconst Vector_1 = require(\"./Vector\");\nconst Cell_1 = require(\"./Cell\");\nexports.FrontVector = new Vector_1.Vector(0, 1);\nexports.RightVector = new Vector_1.Vector(1, 0);\nexports.BackVector = new Vector_1.Vector(0, -1);\nexports.LeftVector = new Vector_1.Vector(-1, 0);\nclass MazeCell extends Cell_1.Cell {\n    constructor(x, y) {\n        super();\n        this._position = new Vector_1.Vector(x, y);\n        this._connected = false;\n    }\n    set Connected(value) {\n        this._connected = value;\n    }\n    get Connected() { return this._connected; }\n    get Position() {\n        return this._position;\n    }\n    get AvailableVectors() {\n        const directions = new Array();\n        if (this.Front == null) {\n            directions.push(exports.FrontVector);\n        }\n        if (this.Right == null) {\n            directions.push(exports.RightVector);\n        }\n        if (this.Back == null) {\n            directions.push(exports.BackVector);\n        }\n        if (this.Left == null) {\n            directions.push(exports.LeftVector);\n        }\n        return directions;\n    }\n    get ConnectionCount() {\n        let count = 0;\n        if (this.Front != null) {\n            count++;\n        }\n        if (this.Right != null) {\n            count++;\n        }\n        if (this.Back != null) {\n            count++;\n        }\n        if (this.Left != null) {\n            count++;\n        }\n        return count;\n    }\n    Barricade() {\n        if (this.Front == null) {\n            this.Front = exports.MazeWall;\n        }\n        if (this.Right == null) {\n            this.Right = exports.MazeWall;\n        }\n        if (this.Back == null) {\n            this.Back = exports.MazeWall;\n        }\n        if (this.Left == null) {\n            this.Left = exports.MazeWall;\n        }\n    }\n    SetCellVector(v, cell) {\n        if (exports.FrontVector.Equals(v)) {\n            this.Front = cell;\n        }\n        else if (exports.RightVector.Equals(v)) {\n            this.Right = cell;\n        }\n        else if (exports.BackVector.Equals(v)) {\n            this.Back = cell;\n        }\n        else if (exports.LeftVector.Equals(v)) {\n            this.Left = cell;\n        }\n    }\n    GetCellVector(v) {\n        if (exports.FrontVector.Equals(v)) {\n            return this.Front;\n        }\n        if (exports.RightVector.Equals(v)) {\n            return this.Right;\n        }\n        if (exports.BackVector.Equals(v)) {\n            return this.Back;\n        }\n        if (exports.LeftVector.Equals(v)) {\n            return this.Left;\n        }\n        return null;\n    }\n}\nexports.MazeCell = MazeCell;\nexports.MazeWall = new MazeCell(-1, -1);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector = void 0;\n//Corey Wunderlich 2022\n//https://www.wundervisionenvisionthefuture.com/\n//A Simple Vector to use that is not dependent on another library\nclass Vector {\n    constructor(x, y) {\n        this._y = y;\n        this._x = x;\n    }\n    get X() { return this._x; }\n    get Y() { return this._y; }\n    Add(v) {\n        return new Vector(this._x + v.X, this._y + v.Y);\n    }\n    Reverse() {\n        return new Vector(this._x * -1, this._y * -1);\n    }\n    Equals(v) {\n        return this._x == v.X && this._y == v.Y;\n    }\n}\nexports.Vector = Vector;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Maze2DMain = void 0;\n//Corey Wunderlich 2022\n//https://www.wundervisionenvisionthefuture.com/\nconst Maze_1 = require(\"./Maze\");\nconst Maze2D_1 = require(\"./Maze2D\");\nclass Maze2DMain {\n    constructor(canvas_id) {\n        this._canvas = document.getElementById(canvas_id);\n        if (this._canvas == null) {\n            throw \"Canvas Not Found\";\n        }\n        this._maze = null;\n        this._maze_renderer = null;\n    }\n    Generate() {\n        this._maze = Maze_1.Maze.Generate(0, 0, 100, 100);\n        if (this._canvas != null) {\n            this._maze_renderer = new Maze2D_1.Maze2D(this._canvas, this._maze);\n            this._maze_renderer.CreateMaze();\n        }\n        return this._maze;\n    }\n}\nexports.Maze2DMain = Maze2DMain;\n"],"names":[],"sourceRoot":""}